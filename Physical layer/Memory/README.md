# Memory functions

## [Dynamic memory allocation](Dynamic%20memory%20allocation.md)

* [new](Dynamic%20memory%20allocation.md#new)
* [delete](Dynamic%20memory%20allocation.md#delete)
* [memset()](Dynamic%20memory%20allocation.md#memset)
* [std::move](Dynamic%20memory%20allocation.md#stdmove): A simple variable, a class object

# [Pointer](Pointer)

C only supports pointer while C++ supports pointers and reference ([lvalue reference](#lvalue) and [rvalue reference](#rvalue))

* [nullptr](Pointer.md#nullptr)
* [Pointer as an object of a class, new keyword](../../Object-oriented%20programming/Fundamental%20concepts.md#define-variable-and-function-for-a-class-use-class-object-as-a-pointer)
* [uintptr_t](https://github.com/TranPhucVinh/Cplusplus/blob/master/Physical%20layer/Memory/Pointer.md#uintptr_t): [Change value of variable by uintptr_t* and uintptr_t&](https://github.com/TranPhucVinh/Cplusplus/blob/master/Physical%20layer/Memory/Pointer.md#change-value-of-variable-by-uintptr_t)
* [Smart pointer](Smart%20pointer): [Unique pointer](Smart%20pointer#Unique%20pointer.md), [shared pointer](Smart%20pointer#Shared%20pointer.md) and weak pointer

# [lvalue](lvalue.md)

* [lvalue define](): [NULL initialization]() and [reinitialization]() aren't allowed
* [lvalue reference as pass by reference](lvalue.md#lvalue-reference-as-pass-by-reference)
* [Return lvalue for a function]()
* [lvalue function with pass by reference](lvalue.md#lvalue-function-with-pass-by-reference)
* [lvalue function with pass by value](lvalue.md#lvalue-function-with-pass-by-value)
* [Choosing between passing by pointer and passing by lvalue reference in C++]()

# [rvalue](rvalue.md)

* [rvalue concept, define rvalue](rvalue.md#define-rvalue)
* [rvalue as class object](rvalue.md#rvalue-as-class-object)
